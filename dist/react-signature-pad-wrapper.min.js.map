{"version":3,"file":"react-signature-pad-wrapper.min.js","sources":["../node_modules/throttle-debounce/throttle.js","../node_modules/throttle-debounce/debounce.js","../src/SignaturePad.js"],"sourcesContent":["/* eslint-disable no-undefined,no-param-reassign,no-shadow */\n\n/**\n * Throttle execution of a function. Especially useful for rate limiting\n * execution of handlers on events like resize and scroll.\n *\n * @param  {Number}    delay          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n * @param  {Boolean}   noTrailing     Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the\n *                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time\n *                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,\n *                                    the internal counter is reset)\n * @param  {Function}  callback       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n *                                    to `callback` when the throttled-function is executed.\n * @param  {Boolean}   debounceMode   If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),\n *                                    schedule `callback` to execute after `delay` ms.\n *\n * @return {Function}  A new, throttled, function.\n */\nmodule.exports = function ( delay, noTrailing, callback, debounceMode ) {\n\n\t// After wrapper has stopped being called, this timeout ensures that\n\t// `callback` is executed at the proper times in `throttle` and `end`\n\t// debounce modes.\n\tvar timeoutID;\n\n\t// Keep track of the last time `callback` was executed.\n\tvar lastExec = 0;\n\n\t// `noTrailing` defaults to falsy.\n\tif ( typeof noTrailing !== 'boolean' ) {\n\t\tdebounceMode = callback;\n\t\tcallback = noTrailing;\n\t\tnoTrailing = undefined;\n\t}\n\n\t// The `wrapper` function encapsulates all of the throttling / debouncing\n\t// functionality and when executed will limit the rate at which `callback`\n\t// is executed.\n\tfunction wrapper () {\n\n\t\tvar self = this;\n\t\tvar elapsed = Number(new Date()) - lastExec;\n\t\tvar args = arguments;\n\n\t\t// Execute `callback` and update the `lastExec` timestamp.\n\t\tfunction exec () {\n\t\t\tlastExec = Number(new Date());\n\t\t\tcallback.apply(self, args);\n\t\t}\n\n\t\t// If `debounceMode` is true (at begin) this is used to clear the flag\n\t\t// to allow future `callback` executions.\n\t\tfunction clear () {\n\t\t\ttimeoutID = undefined;\n\t\t}\n\n\t\tif ( debounceMode && !timeoutID ) {\n\t\t\t// Since `wrapper` is being called for the first time and\n\t\t\t// `debounceMode` is true (at begin), execute `callback`.\n\t\t\texec();\n\t\t}\n\n\t\t// Clear any existing timeout.\n\t\tif ( timeoutID ) {\n\t\t\tclearTimeout(timeoutID);\n\t\t}\n\n\t\tif ( debounceMode === undefined && elapsed > delay ) {\n\t\t\t// In throttle mode, if `delay` time has been exceeded, execute\n\t\t\t// `callback`.\n\t\t\texec();\n\n\t\t} else if ( noTrailing !== true ) {\n\t\t\t// In trailing throttle mode, since `delay` time has not been\n\t\t\t// exceeded, schedule `callback` to execute `delay` ms after most\n\t\t\t// recent execution.\n\t\t\t//\n\t\t\t// If `debounceMode` is true (at begin), schedule `clear` to execute\n\t\t\t// after `delay` ms.\n\t\t\t//\n\t\t\t// If `debounceMode` is false (at end), schedule `callback` to\n\t\t\t// execute after `delay` ms.\n\t\t\ttimeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);\n\t\t}\n\n\t}\n\n\t// Return the wrapper function.\n\treturn wrapper;\n\n};\n","/* eslint-disable no-undefined */\n\nvar throttle = require('./throttle');\n\n/**\n * Debounce execution of a function. Debouncing, unlike throttling,\n * guarantees that a function is only executed a single time, either at the\n * very beginning of a series of calls, or at the very end.\n *\n * @param  {Number}   delay         A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n * @param  {Boolean}  atBegin       Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds\n *                                  after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.\n *                                  (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).\n * @param  {Function} callback      A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n *                                  to `callback` when the debounced-function is executed.\n *\n * @return {Function} A new, debounced function.\n */\nmodule.exports = function ( delay, atBegin, callback ) {\n\treturn callback === undefined ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);\n};\n","import React, {PureComponent} from 'react';\nimport PropTypes from 'prop-types';\nimport SigPad from 'signature_pad';\nimport debounce from 'throttle-debounce/debounce';\n\nclass SignaturePad extends PureComponent {\n\n    static displayName = 'react-signature-pad-wrapper';\n\n    static propTypes = {\n        width: PropTypes.number,\n        height: PropTypes.number,\n        options: PropTypes.object,\n        redrawOnResize: PropTypes.bool.isRequired,\n        debounceInterval: PropTypes.number.isRequired,\n        canvasProps: PropTypes.object\n    }\n\n    static defaultProps = {\n        redrawOnResize: false,\n        debounceInterval: 150\n    }\n\n    constructor(props) {\n        super(props);\n\n        this.state = {canvasWidth: 0, canvasHeight: 0};\n\n        this._callResizeHandler = debounce(\n            this.props.debounceInterval,\n            this.handleResize.bind(this)\n        );\n    }\n\n    componentDidMount() {\n        if (this._canvas) {\n            if (!this.props.width || !this.props.height) {\n                this._canvas.style.width = '100%';\n            }\n            this.scaleCanvas();\n\n            if (!this.props.width || !this.props.height) {\n                window.addEventListener('resize', this._callResizeHandler);\n            }\n\n            this._signaturePad = new SigPad(this._canvas, this.props.options);\n        }\n    }\n\n    componentWillUnmount() {\n        if (!this.props.width || !this.props.height) {\n            window.removeEventListener('resize', this._callResizeHandler);\n        }\n\n        this._signaturePad.off();\n    }\n\n    /**\n     * Get the original signature_pad instance.\n     */\n    get instance() {\n        return this._signaturePad;\n    }\n\n    get canvas() {\n        return this._canvas;\n    }\n\n    set dotSize(dotSize) {\n        this._signaturePad.dotSize = dotSize;\n    }\n\n    get dotSize() {\n        return this._signaturePad.dotSize;\n    }\n\n    set minWidth(minWidth) {\n        this._signaturePad.minWidth = minWidth;\n    }\n\n    get minWidth() {\n        return this._signaturePad.minWidth;\n    }\n\n    set maxWidth(maxWidth) {\n        this._signaturePad.maxWidth = maxWidth;\n    }\n\n    get maxWidth() {\n        return this._signaturePad.maxWidth;\n    }\n\n    set throttle(throttle) {\n        this._signaturePad.throttle = throttle;\n    }\n\n    get throttle() {\n        return this._signaturePad.throttle;\n    }\n\n    set backgroundColor(color) {\n        this._signaturePad.backgroundColor = color;\n    }\n\n    get backgroundColor() {\n        return this._signaturePad.backgroundColor;\n    }\n\n    set penColor(color) {\n        this._signaturePad.penColor = color;\n    }\n\n    get penColor() {\n        return this._signaturePad.penColor;\n    }\n\n    set velocityFilterWeight(weight) {\n        this._signaturePad.velocityFilterWeight = weight;\n    }\n\n    get velocityFilterWeight() {\n        return this._signaturePad.velocityFilterWeight;\n    }\n\n    set onBegin(fn) {\n        if (!(fn && typeof fn === 'function')) {\n            throw new Error('Invalid argument passed to onBegin()');\n        }\n\n        this._signaturePad.onBegin = fn;\n    }\n\n    set onEnd(fn) {\n        if (!(fn && typeof fn === 'function')) {\n            throw new Error('Invalid argument passed to onEnd()');\n        }\n\n        this._signaturePad.onEnd = fn;\n    }\n\n    isEmpty() {\n        return this._signaturePad.isEmpty();\n    }\n\n    clear() {\n        this._signaturePad.clear();\n    }\n\n    fromDataURL(base64String) {\n        this._signaturePad.fromDataURL(base64String);\n    }\n\n    toDataURL(mime) {\n        return this._signaturePad.toDataURL(mime);\n    }\n\n    fromData(data) {\n        this._signaturePad.fromData(data);\n    }\n\n    toData() {\n        return this._signaturePad.toData();\n    }\n\n    off() {\n        this._signaturePad.off();\n    }\n\n    on() {\n        this._signaturePad.on();\n    }\n\n    handleResize() {\n        this.scaleCanvas();\n    }\n\n    scaleCanvas() {\n        const ratio = Math.max(window.devicePixelRatio || 1, 1);\n        const width = (this.props.width || this._canvas.offsetWidth) * ratio;\n        const height = (this.props.height || this._canvas.offsetHeight) * ratio;\n\n        // Avoid needlessly setting height/width if dimensions haven't changed\n        const {canvasWidth, canvasHeight} = this.state;\n        if (width === canvasWidth && height === canvasHeight) return;\n\n        let data;\n        if (this.props.redrawOnResize && this._signaturePad) {\n            data = this._signaturePad.toDataURL();\n        }\n\n        this._canvas.width = width;\n        this._canvas.height = height;\n\n        this.setState({canvasWidth: width, canvasHeight: height});\n\n        const ctx = this._canvas.getContext('2d');\n        ctx.scale(ratio, ratio);\n\n        if (this.props.redrawOnResize && this._signaturePad) {\n            this._signaturePad.fromDataURL(data);\n        } else if (this._signaturePad) {\n            this._signaturePad.clear();\n        }\n    }\n\n    render() {\n        const {canvasProps} = this.props;\n\n        return (\n            <canvas\n                ref={ref => this._canvas = ref}\n                {...canvasProps} />\n        );\n    }\n\n}\n\nexport default SignaturePad;\n"],"names":["delay","noTrailing","callback","debounceMode","timeoutID","lastExec","undefined","self","this","elapsed","Number","Date","args","arguments","exec","apply","clearTimeout","setTimeout","atBegin","throttle","SignaturePad","props","state","canvasWidth","canvasHeight","_callResizeHandler","debounce","_this","debounceInterval","handleResize","bind","_canvas","width","height","style","scaleCanvas","addEventListener","_signaturePad","SigPad","options","removeEventListener","off","isEmpty","clear","base64String","fromDataURL","mime","toDataURL","data","fromData","toData","on","ratio","Math","max","window","devicePixelRatio","offsetWidth","offsetHeight","redrawOnResize","setState","getContext","scale","canvasProps","React","_this2","ref","dotSize","minWidth","maxWidth","color","backgroundColor","penColor","weight","velocityFilterWeight","fn","Error","onBegin","onEnd","PureComponent","displayName","propTypes","PropTypes","number","object","bool","isRequired","defaultProps"],"mappings":"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"}